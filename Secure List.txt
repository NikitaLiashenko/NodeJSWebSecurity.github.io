Secure List
1.Web application should not be run with root privileges.
2.DB account should not be root account.
3.The users of web app should be given the minimum set of priviledges.
4.Use dedicated mashines. Mashine should host your app only.Don't use it for anything else.
5.Keep access to the production server to a minimum.
6.Don't use any default passwords or keys.Use keys generated by you.
7.Set up propper firewall.(HOW???)NEED MORE INFO
8.Keep packages up-to-date
9.CHECK LINUX SERVER SECURITY
10.Use separate development and production servers as well as DBs
11.Use configuration tools(like nconf)
12.Limit error messages in production
13.Determine every package version
14.Transport layer security
15.Don't use self-signed SSl certificates in production (at least use startssl.com)
16.If you use HTTPS(use it every time), you should make simple HTTP redirect server
17.Use nginx to handle ssl connection.It's too hard for Node.
18.Use HSTS(Set Strict-Transport-Security header like this: res.set('Strict-Transport-Security', 'max-age=' + <put time in seconds> + ';includeSubdomains');)
This will work only if you send it over HTTPS and have proper certificate(not self-signed)
If you use nginx, you should set protection headers in the proxt configuration.
CHECK MOZILLA HSTS article
19.Use morgan as logging system.It will help to check requests and know, how thee attack was made.(Example: app.use(morgan('combined')); combined is the best option for logging)
CHECK MORGAN AND MONGO-MORGAN API
20.Every emitter must have error listener
21.Try to avoid creating any code using user-submitted data(don't believe user-submitted data)
22.If you should exec something:
1)try to change exec to execFile
2)validate input
3)limit run rights(check Secure Your Node.JS Web App book, page 50)
23.Use express-ipfilter module if you see atack from certain IP-address(CHECK express-ipfilter module)
24.Set special roles for every user in DB
CHECK mongoose-multitenant or something like this
25.Defend from SQL injection:
1)Reduce error messages
2)Validate all inputs
3)Escape user input
4)Use prepared queries(if it's possible)
26.Defend from NoSQL injections:
1)validate inputs
2)Escape inputs
CHECK Hacking and Atacking Node.JS and MongoDB articles
27.Don't use Mongo everywhere.It's not good for everything
28.One problem with mongo is concurent attack(CHECK HOW TO AVOID)
29.Never store passwords in plain text
30.Don't use MD5, SHA1, SHA256, SHA512 and SHA3 for hashing. All this algos designed to calculate hash as fast as possible.(use bcrypt or scrypt instead.scrypt is better)
31. You can upgrade storing password with MongoDB prehooks and validate password using MongoDB custom methods, or you can use classic API routes? put all this functionality in route and use MongoDB as store only.
32.Check user passwords itself. Password must not contain username. Password must not be in a list of bad passwords (https://wiki.skullsecurity.org/index.php?title=Passwords)
33. Instead of forsing user to create password with special characters, that are hard to remember, have them select longer passwords. Changing password periodically is good suggestion (If you use it don't let users to write previously used passwords.keep the previous hashes and compare the hash of the new one to make sure the user isn’t trying to reuse the password.)
34.Use HTTPS not only for login and register pages, but for the whole site. Your session will be stolen if you use HTTP for the other pages.
35.Do not send a plain-text password to the user's email as a reminder.
36.If application is generating password on the user's behalf, force the user to change it immediately the first time user logs in.
37.Insert delays in login system. You can block ip after some failed attempts, but use it carefully. Also you can secure app against parallel checks. CHECK P 95-96
38.If login failled don't say, which field is incorrect
39.If you have email-based recovery system, always validate user's email address. Don't let user change it without revalidating.
40.You can have two-password authentication.One password you use for real authentication,  the other you will use for special requests.
СHECK OWASP SESSION MANAGEMENT CHEAT SHEET
41.Use connect-redis for storing sessions(CHECK P 101)
42.In express-session use more generic name prop value ( 'id' ) for not to share info about application
43.Set session timeout to 5 minutes if it's highly protected applications and no more than twenty minutes for low-risk applications.
Also you can use two-tier system which gives you full access right after login, but reduce your access after a few minutes
CHECK P 103 for implementation
44.Use httpOnly setting for every cookie
45.If it's possible, limit cookie exposure
46.Don't cache any cookies( res.header('Cache-Control', 'no-cache="Set-Cookie, Set-Cookie2"'))
47.Recreate session when the user logs in
CHECK P 106 for implementation
48.You can bind additional info to session to prevent hijacking
CHECK P 107-108 for implementation
Best module for session management - easy-session
CHECK acl and easy-rbac modules
49.Check function-level access control holes. If you have priveledged functions nobody non-authorized should know about existense of this function.The same thing with pages. Worry about client-side build pathes.Nobody non-authorized should know anything about authorized pathes.
50.Client side validation does not substitute for server-side validation. Don't forget about server-side validation.
51.Don't use direct references unless they are necessary.
52.Validate access rights to an object when the object is accessed.
53.Never hardcode user roles. Use custom functions to check user roles.
54.Avoid synchronous code
CHECK Node inspector, spy.js or node webkit agent for understanding how to find performance issues
55.To avoid Denial-of-service attack you can limit amount of requests from single IP per some time.
Remember, you should check maximum requests per second for every application!!!
56. Disable TRACE method calls on your server
57. Set up Content Security Policy header (res.header('Content-Security-Policy', "default-src 'self'"))
CHECK OWASP XSS Prevention Cheat Sheet (https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet)
CHECK node-esapi module and use it for sanitizing html
58.Escape untrusted data inserted into HTML element content(jade do this automatically)
(ESAPI.encoder().encodeForHTML(untrustedData);)
59.Sanitize HTML markup
Use sanitizer module and it's sanitize() function
60.Escape untrusted data inserted into HTML attributes
(ESAPI.encoder(),encodeForHTMLAttributes(untrustedData);)
Don't trust such functions as setAttribute() and other that takes code as strings. It's better to set element attribute directly.
61.Escape untrusted data inserted into JavaScript data values
(ESAPI.encoder().encodeForJS(untrustedData); or ESAPI.encoder().encodeForJavaScript(untrustedData); or ESAPI.encoder().encodeForJavascript(untrustedData);)
62.Escape JSON values in an HTML context and read data with JSON.parse
If you want to put JSON data inside HTML do it in a such way : ESAPI.encoder().encodeForHTML(JSON.stringify(data))
If you want to get this data select it and use JSON.parse(jsonText) NOT eval(jsonText). NEVER USE F***ING EVAL!!!
63. Escape and validate untrusted data inserted into CSS property values
(ESAPI.encoder().encodeForCSS(untrustedData);)
64.Escape untrusted data inserted into HTML URL parameter values.
(ESAPI.encoder().encodeForURL(untrustedData);)
CHECK OWASP DOM-based XSS Prevention Cheat Sheet (https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet)
65.Use DOM construction methods instead of HTML interpretation.
66.Javascript and HTML encode nefore HTML subcontext.
Put encoded data inside Javascript HTML render methods. You can wrap two encodings one by another:
(ESAPI.encoder().encodeForJS(ESAPI.encoder().encodeForHTML(unsafeData));)
67.If you are using CORS be sure to minimize permissions you allow
68.Never trust GET requests. Never allow GET requests to change anything.
CHECK csurf module
69.To protect app from CSRF attack include csurf method and construct all forms with hidden input and csurfToken inside
CHECK p 163 for implementation and p 164 for error handling implementation
Also you can use double-submit cookie with csurfToken CHECK p 165 for implementation
Protect all your forms, not only authentication
If you want to defeat CSRF attack, then you need to master XSS first
70.When you are using forms collecting sensitive information, you should either turn off autocomplete entirely.
71. Set cache control header not to cache pages with sensitive info
(res.header('Cache-Control', 'no-store');) But think carefully where to use it. no-cache header increases server load.
72.Never log any sensitive info.You can log it only after masking it
73.Try to open as few directories as possible or check all info you use as "public". Limit public access folders.
74.Check valid paths when user gets any file.Also check it when user puts any file, too.
75.If you want to save data propperly, you should encrypt it first. But it's not good to encrypt everything with one key, so you should generate random key for every user,then encrypt data with this key, then encrypt this key with user password and store both encrypted data and encrypted key in store.When user want to get data use it's password to decrypt key, then decrypt data, then give that data to user.
BUT, DON'T ENCRYPT EVERYTHING!Encryption is very resource-heavy process.Encrypt only sensitive data.
CHECK OWASP Risk rating methodology (https://www.owasp.org/index.php/OWASP_Risk_Rating_Methodology)
CHECK OWASP Threat Risk Modeling (https://www.owasp.org/index.php/Threat_Risk_Modeling)
76.Use helmet module
77.Use nsp module to check if you are using some modules, which are vulnerable
CHECK OWASP Application Security Verification Standard (https://www.owasp.org/images/5/58/OWASP_ASVS_Version_2.pdf)
78.Use non standard password match algorythm to defend against timing attack (check https://snyk.io/blog/node-js-timing-attack-ccc-ctf/)
CHECK OWASP NodeGoat Tutorial (https://github.com/OWASP/NodeGoat)
CHECK OWASP Web Application Security Testing Cheat Sheet (https://www.owasp.org/index.php/Web_Application_Security_Testing_Cheat_Sheet)
CHECK Hacking: The Art of Exploitation book
Use metasploit or Kali or burp to check security (http://www.metasploit.com/   https://www.kali.org/   https://portswigger.net/burp/)

