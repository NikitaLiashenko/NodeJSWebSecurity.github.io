{
  "name": "nodejswebsecurity.github.io",
  "tagline": "Short doc about Securing Node.JS App based on Karl Duuna's \"Secure your Node.JS Web Application\" book.",
  "body": "### Currently not finished\r\n# All code was brought from the book. Author is Karl Duuna. Published by The Pragmatic Bookshelf.\r\n\r\n\r\n\r\n\r\n\r\n# Security List\r\n\r\n\r\n   * Web application should not be run with root priviledges.\r\n   * DB account should not be root account.\r\n   * The users of web app should be given the minimum set of priviledges.\r\n   * Use dedicated mashines. Mashine should host your app only.Don't use it for anything else.\r\n   * Keep access to the production server to a minimum.\r\n   * Don't use any default passwords or keys.Use keys generated by you.\r\n   * Set up propper firewall. \r\n   (HOW???)NEED MORE INFO\r\n   * Keep packages up-to-date\r\n   \r\n   *check linux server security*\r\n   \r\n   * Use separate development and production servers as well as DBs\r\n   * Use configuration tools(like nconf module)\r\n   * Limit error messages in production\r\n   * Determine every module version\r\n   * Transport layer security\r\n   * Don't use self-signed SSl certificates in production (at least use [StartSSL](http://startssl.com))\r\n   * If you use HTTPS(use it every time), you should make simple HTTP redirect server\r\n   * Use nginx to handle ssl connection.It's too hard for Node.\r\n   * Use HSTS\r\n   Set Strict-Transport-Security header like this:\r\n   ```\r\n        res.set('Strict-Transport-Security', 'max-age=' + <put time in seconds> + ';includeSubdomains');\r\n   ```\r\n   This will work only if you send it over HTTPS and have proper certificate(not self-signed)\r\n   If you use nginx, you should set protection headers in the proxy configuration.\r\n   \r\n   *check mozilla HSTS article*\r\n   \r\n   * Use morgan as logging system.It will help to check requests and know, how thee attack was made.\r\n   ```\r\n        app.use(morgan('combined'));\r\n   ```\r\n   `combined` is the best option for logging\r\n   \r\n   *check morgan and mongo-morgan API*\r\n   \r\n   * Every emitter must have error listener\r\n   * Try to avoid creating any code using user-submitted data(don't believe user-submitted data)\r\n   * If you should exec something:\r\n    1. try to change exec to execFile\r\n    2. validate input\r\n    3. limit run rights\r\n    ```javascript\r\n    var opts = {};\r\n    app.post('/host', function (req, res) {\r\n        // Add options specifying uid, which we asked from system\r\n        execFile('/usr/bin/host', [req.body.host],\r\n            opts, function (err, stdout, stderr) {\r\n                if(err || stderr) {\r\n                    console.error(err || stderr);\r\n                    res.sendStatus(500);\r\n                    return;\r\n                }\r\n                res.send(\r\n                    '<h3>Lookup for: ' + req.body.host + '</h3>' +\r\n                    '<pre>' + stdout + '</pre>' +\r\n                    form\r\n                );\r\n            });\r\n    });\r\n    // Look for the nobody user\r\n    // NOTE:\r\n    // On OSX this can cause an error because the UID of nobody\r\n    // is a negative number (-1) represented by overflowing integer\r\n    execFile('/usr/bin/id', ['-u', 'nobody'], function (err, stdout, stderr) {\r\n        if(err || stderr) {\r\n            console.error(err || stderr);\r\n            process.exit(1);\r\n        }\r\n        // Set the uid in the options\r\n        opts.uid = +stdout;\r\n        // Start server\r\n        console.log('Nobody is ' + opts.uid);\r\n        console.log('Listening on 3000');\r\n        app.listen(3000);\r\n    });\r\n    ```\r\n   * Use `express-ipfilter` module if you see attack from certain IP-address\r\n    \r\n   *check `express-ipfilter` module*\r\n    \r\n   * Set special roles for every user in DB\r\n    \r\n   *check `mongoose-multitenant` or something like this*\r\n    \r\n   * Defend from SQL injection:\r\n    1. Reduce error messages in production\r\n    2. Validate all inputs\r\n    3. Escape user input\r\n    4. Use prepared queries (if it's possible)\r\n   * Defend from NoSQL injections:\r\n    1. Validate inputs\r\n    2. Escape inputs\r\n   \r\n   *check hacking and attacking Node.JS and MongoDB articles*\r\n   \r\n   * Don't use MongoDB everywhere.It's not good for everything\r\n   * One problem with mongo is concurent attack\r\n   \r\n   *check how to avoid*\r\n   \r\n   * Never store passwords in plain text\r\n   * Don't use MD5, SHA1, SHA256, SHA512 and SHA3 for hashing. All this algos designed to calculate hash as fast as possible. (use `bcrypt` or `scrypt` instead. `scrypt` is better)\r\n   * You can upgrade storing password with MongoDB prehooks and validate password using MongoDB custom methods, or you can use classic API routes? put all this functionality in route and use MongoDB as store only.\r\n   * Check user passwords itself. Password must not contain username. Password must not be in a [List of bad passwords](https://wiki.skullsecurity.org/index.php?title=Passwords)\r\n   * Instead of forsing user to create password with special characters, that are hard to remember, have them select longer passwords. Changing password periodically is good suggestion (If you use it don't let users to write previously used passwords.keep the previous hashes and compare the hash of the new one to make sure the user isnâ€™t trying to reuse the password.)\r\n   * Use HTTPS not only for login and register pages, but for the whole site. Your session will be stolen if you use HTTP for the other pages.\r\n   * Do not send a plain-text password to the user's email as a reminder.\r\n   * If application is generating password on the user's behalf, force the user to change it immediately the first time user logs in.\r\n   * Insert delays in login system. You can block ip after some failed attempts, but use it carefully. Also you can secure app against parallel checks.\r\n    ```\r\n    var maxFailedCount = 5; // Max tries\r\n    var forgetFailedMins = 15; // time the user will be blocked\r\n    var blockList = {};\r\n    // Check if ip is still allowed\r\n    function isAllowed(ip) {\r\n       return !blockList[ip] || blockList[ip].count < maxFailedCount;\r\n    }\r\n    // Remove ip from blockList\r\n    function successfulAttempt(ip) {\r\n       if(blockList[ip]) {\r\n           if(blockList[ip].timeout) {\r\n               clearTimeout(blockList[ip].timeout);\r\n           }\r\n           delete blockList[ip];\r\n       }\r\n   }\r\n   // Increment blocklist counter\r\n   function failedAttempt(ip) {\r\n       if(!blockList[ip]) {\r\n           blockList[ip] = {\r\n               count: 0\r\n           };\r\n       }\r\n       blockList[ip].count++;\r\n       if(blockList[ip].timeout) {\r\n           clearTimeout(blockList[ip].timeout);\r\n       }\r\n       blockList[ip].timeout = setTimeout(function () {\r\n           delete blockList[ip];\r\n       }, forgetFailedMins * 60 * 1000);\r\n   }\r\n   app.post('/login', function (req, res, next) {\r\n       if(!isAllowed(req.ip)) { // Check if user is blocked\r\n           req.session.error = 'You have been blocked for ' +\r\n               forgetFailedMins + ' minutes';\r\n           res.redirect('/');\r\n           return;\r\n       }\r\n       validateUser(req.body, function(err, valid) {\r\n           if(err) {\r\n               next(err);\r\n               return;\r\n           }\r\n           if(valid.success) { // Validation success. Create authorized session.\r\n               successfulAttempt(req.ip); // Clear from blocklist\r\n               req.session.login({userId: valid.userId}, function () {\r\n                   res.redirect('/user/' + valid.userId);\r\n               });\r\n           } else {\r\n               failedAttempt(req.ip); // Register the failed attempt\r\n               req.session.error = valid.error;\r\n               res.redirect('/');\r\n           }\r\n       });\r\n   });\r\n    ```\r\n    ```\r\n    app.post('/login', function (req, res, next) {\r\n        function end(url) {\r\n            setTimeout(function () {\r\n                res.redirect(url);\r\n            }, 1000);\r\n        }\r\n        validateUser(req.body, function(err, valid) {\r\n            if(err) {\r\n                next(err);\r\n                return;\r\n            }\r\n            if(valid.success) { // Validation success. Create authorized session.\r\n                req.session.login({userId: valid.userId}, function () {\r\n                    // delay before answer\r\n                    end('/user/' + valid.userId);\r\n                });\r\n            } else {\r\n                req.session.error = valid.error;\r\n                // delay before answering\r\n                end('/');\r\n            }\r\n        });\r\n    });\r\n    ```\r\n    ```\r\n    var inProgress = {};\r\n    app.post('/login', function (req, res, next) {\r\n        var key = req.ip + ':' + req.body.username;\r\n        // check if we are already authenticating this user from the given IP\r\n        if(inProgress[key]) {\r\n            req.session.error = 'Authentication already in progress';\r\n            res.redirect('/');\r\n            return;\r\n        }\r\n        inProgress[key] = true;\r\n        function end(url) {\r\n            setTimeout(function () {\r\n                delete inProgress[key];\r\n                res.redirect(url);\r\n            }, 1000);\r\n        }\r\n        validateUser(req.body, function(err, valid) {\r\n            if(err) {\r\n                delete inProgress[key];\r\n                next(err);\r\n                return;\r\n            }\r\n            if(valid.success) { // Validation success. Create authorized session.\r\n                req.session.login({userId: valid.userId}, function () {\r\n                    // delay before answer\r\n                    end('/user/' + valid.userId);\r\n                });\r\n            } else {\r\n                req.session.error = valid.error;\r\n                // delay before answering\r\n                end('/');\r\n            }\r\n        });\r\n    });\r\n    ```\r\n   * If login failed don't say, which field is incorrect\r\n   * If you have email-based recovery system, always validate user's email address. Don't let user change it without revalidating.\r\n   * You can have two-password authentication.One password you use for real authentication,  the other you will use for special requests.\r\n   \r\n   *check OWASP session management cheat sheet*\r\n   \r\n   * Use `connect-redis` for storing sessions\r\n    ```\r\n    var express = require('express');\r\n    var RedisStore = require('connect-redis')(express); // Require connect-redis\r\n    var session = require('express-session');\r\n    var cookieParser = require('cookie-parser');\r\n    var app = express();\r\n    app.use(cookieParser());\r\n    app.use(session({\r\n            store: new RedisStore({\r\n            host: 'localhost',\r\n            port: 6379,\r\n            db: 2,\r\n            pass: 'funky password here' // <- specify password\r\n        }),\r\n        secret: 'this is a nice secret',\r\n        resave: false,\r\n        saveUninitialized: true\r\n    }));\r\n    ```\r\n   * In `express-session` use more generic name prop value ( 'id' ) for not to share info about application\r\n   * Set session timeout to 5 minutes if it's highly protected applications and no more than twenty minutes for low-risk applications.\r\n   Also you can use two-tier system which gives you full access right after login, but reduce your access after a few minutes\r\n    ```\r\n    var session = require('express-session');\r\n    var RedisStore = require('connect-redis')(session); // Require connect-redis\r\n    // Extend the Session prototype with some custom functions\r\n    // Add a login function\r\n    session.Session.prototype.login = function login() {\r\n        // Set a time of login\r\n        this.session._loggedInAt = Date.now();\r\n    };\r\n    // Add a function to check the logged in status of the user\r\n    session.Session.prototype.isLoggedIn = function isLoggedIn() {\r\n        return !!this._loggedInAt;\r\n    };\r\n    // Add a function to check the freshness of the session\r\n    session.Session.prototype.isFresh = function isFresh() {\r\n        // Return true if logged in less then 3 minutes ago\r\n        return (this._loggedInAt && (Date.now() - this._loggedInAt) < (1000 * 60 * 3));\r\n    };\r\n    app.use(cookieParser());\r\n    app.use(session({\r\n        store: new RedisStore({ // specify the usage of RedisStore\r\n            host: 'localhost',\r\n            port: 6379,\r\n            db: 2,\r\n            pass: 'funky password here', //  specify password\r\n            ttl: (20 * 60) // TTL of 20 minutes represented in seconds\r\n        }),\r\n        name: 'id', // use a generic id\r\n        secret: 'this is a nice secret',\r\n        resave: false,\r\n        saveUninitialized: true\r\n    }));\r\n    app.get('/', function(req, res){\r\n        if(!req.session.views) {\r\n            req.session.views = 0;\r\n        }\r\n        req.session.views++;\r\n        res.send('hello world. ' + req.session.views + ' times so far.');\r\n    });\r\n    app.get('/login', function (req, res) {\r\n        req.session.login()\r\n        res.send('ok - ' + req.session._loggedInAt);\r\n    });\r\n    app.get('/secure', function (req, res) {\r\n        if(!req.session.isLoggedIn()) { // Check if user is logged in\r\n            res.send(401);\r\n            return;\r\n        }\r\n        res.send('Access');\r\n    });\r\n    app.get('/secure/more', function (req, res) {\r\n        if(!req.session.isFresh()) { // Check if session is fresh\r\n            res.send(401);\r\n            return;\r\n        }\r\n        res.send('You are fresh');\r\n    });\r\n    ```\r\n   * Use httpOnly setting for every cookie\r\n   * If it's possible, limit cookie exposure\r\n   * Don't cache any cookies\r\n   `res.header('Cache-Control', 'no-cache=\"Set-Cookie, Set-Cookie2\"');`\r\n   * Recreate session when the user logs in\r\n    ```\r\n    session.Session.prototype.login = function login(cb) {\r\n        var req = this.req;\r\n        this.regenerate(function (err) {\r\n            if(err) {\r\n                cb(err);\r\n                return;\r\n            }\r\n            req.session._loggedInAt = Date.now();\r\n            cb();\r\n        });\r\n    };\r\n    ```\r\n   * You can bind additional info to session to prevent hijacking\r\n    ```\r\n    session.Session.prototype.login = function login(cb) {\r\n        var req = this.req;\r\n        this.regenerate(function (err) {\r\n            if(err) {\r\n                cb(err);\r\n                return;\r\n            }\r\n            req.session._loggedInAt = Date.now();\r\n            req.session._ip = req.ip;\r\n            req.session._ua = req.headers['user-agent'];\r\n            cb();\r\n        });\r\n    };\r\n    // Check Session information\r\n    app.use(function (req, res, next) {\r\n        if(!req.session) { // If there is no session then something is wrong\r\n            next(new Error('Session object missing'));\r\n            return;\r\n        }\r\n        if(req.session.isGuest()) { // If not logged in then continue\r\n            next();\r\n            return;\r\n        }\r\n        if(req.session._ip !== req.ip) { // Check ip match\r\n            // It would be wise to log more information here\r\n            // to either notify the user or\r\n            // to try and prevent further attacks\r\n            console.warn('The request IP did not match session IP');\r\n            // Generate a new unauthenticated session\r\n            req.session.regenerate(function () {\r\n                next();\r\n            });\r\n            return;\r\n        }\r\n        if(req.session._ua !== req.headers['user-agent']) { // Check UA validity\r\n            // It would be wise to log more information here\r\n            // to either notify the user or\r\n            // to try and prevent further attacks\r\n            console.warn('The request User Agent did not match session user agent');\r\n            // Generate a new unauthenticated session\r\n            req.session.regenerate(function () {\r\n                next();\r\n            });\r\n            return;\r\n        }\r\n        // Everything checks out so continue\r\n        next();\r\n    });\r\n    ```\r\n   Best module for session management - `easy-session`\r\n   \r\n   *check `acl` and `easy-rbac` modules*\r\n   \r\n   * Check function-level access control holes. If you have priveledged functions nobody non-authorized should know about existense of this function.The same thing with pages. Worry about client-side build pathes.Nobody non-authorized should know anything about authorized pathes.\r\n   * Client side validation does not substitute for server-side validation. Don't forget about server-side validation.\r\n   * Don't use direct references unless they are necessary.\r\n   * Validate access rights to an object when the object is accessed.\r\n   * Never hardcode user roles. Use custom functions to check user roles.\r\n   * Avoid synchronous code\r\n   \r\n   *check Node inspector, spy.js or node webkit agent for understanding how to find performance issues*\r\n   \r\n   * To avoid Denial-of-service attack you can limit amount of requests from single IP per some time.\r\n   Remember, you should check maximum requests per second for every application!!!\r\n   * Disable TRACE method calls on your server\r\n   * Set up Content Security Policy header\r\n   `res.header('Content-Security-Policy', \"default-src 'self'\");`\r\n   \r\n   *check [OWASP XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet)*\r\n   \r\n   *check `node-esapi` module and use it for sanitizing html*\r\n   \r\n   * Escape untrusted data inserted into HTML element content(jade do this automatically)\r\n   `ESAPI.encoder().encodeForHTML(untrustedData);`\r\n   * Sanitize HTML markup\r\n     Use `sanitizer` module and it's sanitize() function\r\n   * Escape untrusted data inserted into HTML attributes\r\n   `ESAPI.encoder(),encodeForHTMLAttributes(untrustedData);`\r\n   Don't trust such functions as setAttribute() and other that takes code as strings. It's better to set element attribute directly.\r\n   * Escape untrusted data inserted into JavaScript data values\r\n   `ESAPI.encoder().encodeForJS(untrustedData);` or `ESAPI.encoder().encodeForJavaScript(untrustedData);` or `ESAPI.encoder().encodeForJavascript(untrustedData);`\r\n   * Escape JSON values in an HTML context and read data with JSON.parse\r\n    If you want to put JSON data inside HTML do it in a such way :\r\n   `ESAPI.encoder().encodeForHTML(JSON.stringify(data));`\r\n   If you want to get this data select it and use `JSON.parse(jsonText)` NOT `eval(jsonText)`. NEVER USE EVAL!!!\r\n   * Escape and validate untrusted data inserted into CSS property values\r\n   `ESAPI.encoder().encodeForCSS(untrustedData);`\r\n   * Escape untrusted data inserted into HTML URL parameter values.\r\n   `ESAPI.encoder().encodeForURL(untrustedData);`\r\n   \r\n   *check [OWASP DOM-based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet)*\r\n   \r\n   * Use DOM construction methods instead of HTML interpretation.\r\n   * Javascript and HTML encode nefore HTML subcontext.\r\n     Put encoded data inside Javascript HTML render methods. You can wrap two encodings one by another:\r\n     `ESAPI.encoder().encodeForJS(ESAPI.encoder().encodeForHTML(unsafeData));`\r\n   * If you are using CORS be sure to minimize permissions you allow\r\n   * Never trust GET requests. Never allow GET requests to change anything.\r\n   \r\n   *check `csurf` module*\r\n   \r\n   * To protect app from CSRF attack include csurf method and construct all forms with hidden input and csurfToken inside.\r\n    ```\r\n    app.use(cookieParser());\r\n    app.use(session({\r\n            secret: 'this is a nice secret',\r\n            resave: false,\r\n            saveUninitialized: true\r\n    }));\r\n    app.use(bodyParser.urlencoded());\r\n    app.use(csurf()); // Include csurf middleware\r\n    // Show form\r\n    app.get('/', function (req, res, next) {\r\n        var form = '<form method=\"POST\" action=\"/add\">' +\r\n                        '<input type=\"hidden\" name=\"_csrf\" value=\"' +\r\n                        req.csrfToken() + '\" />' + // add hidden token field\r\n                        '<input type=\"text\" name=\"name\" placeholder=\"name\" />' +\r\n                        '<input type=\"text\" name=\"value\" placeholder=\"value\" />' +\r\n                        '<input type=\"submit\" value=\"Submit\" />' +\r\n                    '</form>';\r\n        res.send(form);\r\n    });\r\n    ```\r\n    ```\r\n    // error handler\r\n    app.use(function (err, req, res, next) {\r\n        if (err.code !== 'EBADCSRFTOKEN') {\r\n            return next(err) // some other error\r\n        }\r\n        // handle CSRF token errors here\r\n        // Besides just saying that we had a mismatch\r\n        // we should log some useful information about the request here\r\n        // like the user and referrer and origin headers of the request for example\r\n        console.warn('CSRF token mismatch');\r\n        res.status(403)\r\n        res.send('form tampered with')\r\n    });\r\n    ```\r\n   Also you can use double-submit cookie with csurfToken\r\n    ```\r\n    // Include csurf middleware, with cookie option\r\n    app.use(csurf({cookie: true}));\r\n    // Show form\r\n    app.get('/', function (req, res, next) {\r\n        var form = '<form method=\"POST\" action=\"/add\">' +\r\n                        '<input type=\"hidden\" name=\"_csrf\" value=\"' +\r\n                        req.csrfToken() + '\" />' + // add hidden token field\r\n                        '<input type=\"text\" name=\"name\" placeholder=\"name\" />' +\r\n                        '<input type=\"text\" name=\"value\" placeholder=\"value\" />' +\r\n                        '<input type=\"submit\" value=\"Submit\" />' +\r\n                    '</form>';\r\n        res.send(form);\r\n    });\r\n    ```\r\n   Protect all your forms, not only authentication\r\n   If you want to defeat CSRF attack, then you need to master XSS first\r\n   * When you are using forms collecting sensitive information, you should either turn off autocomplete entirely.\r\n   * Set cache control header not to cache pages with sensitive info\r\n   `res.header('Cache-Control', 'no-store');`\r\n   But think carefully where to use it. no-cache header increases server load.\r\n   * Never log any sensitive info.You can log it only after masking it\r\n   * Try to open as few directories as possible or check all info you use as \"public\". Limit public access folders.\r\n   * Check valid paths when user gets any file.Also check it when user puts any file, too.\r\n   * If you want to save data propperly, you should encrypt it first. But it's not good to encrypt everything with one key, so you should generate random key for every user,then encrypt data with this key, then encrypt this key with user password and store both encrypted data and encrypted key in store.When user want to get data use it's password to decrypt key, then decrypt data, then give that data to user.\r\n     BUT, DON'T ENCRYPT EVERYTHING!Encryption is very resource-heavy process.Encrypt only sensitive data.\r\n   \r\n   *check [OWASP Risk rating methodology](https://www.owasp.org/index.php/OWASP_Risk_Rating_Methodology)*\r\n   \r\n   *check [OWASP Threat Risk Modeling](https://www.owasp.org/index.php/Threat_Risk_Modeling)*\r\n   \r\n   * Use `helmet` module\r\n   * Use `nsp` module to check if you are using some modules, which are vulnerable\r\n   \r\n   *check [OWASP Application Security Verification Standard](https://www.owasp.org/images/5/58/OWASP_ASVS_Version_2.pdf)*\r\n   \r\n   * Use non standard password match algorythm to defend against timing attack\r\n   \r\n   *check [Node.JS timing](https://snyk.io/blog/node-js-timing-attack-ccc-ctf/)*\r\n   \r\n   *check [OWASP NodeGoat Tutorial](https://github.com/OWASP/NodeGoat)*\r\n   \r\n   *check [OWASP Web Application Security Testing Cheat Sheet](https://www.owasp.org/index.php/Web_Application_Security_Testing_Cheat_Sheet)*\r\n   \r\n   *check Hacking: The Art of Exploitation book*\r\n   \r\n   * Use metasploit or Kali or burp to check security (http://www.metasploit.com/   https://www.kali.org/   https://portswigger.net/burp/)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}